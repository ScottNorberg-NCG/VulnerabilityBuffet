using Microsoft.AspNetCore.Http;
using Microsoft.EntityFrameworkCore;
using NCG.SecurityDetection.VulnerabilityBuffet.Data;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace NCG.SecurityDetection.VulnerabilityBuffet.Authentication
{
    public class AuthManager
    {
        private readonly HttpContext _httpContext;
        private readonly ApplicationDbContext _dbContext;
        private const string AUTH_COOKIE_USER_NAME = "AUTH_USER";
        private const string AUTH_COOKIE_USER_PASSWORD = "AUTH_PASSWORD";

        public enum SignInResult
        { 
            UserNotFound,
            PasswordMismatch,
            Success
        }

        //Hard-coding keys is NOT A GOOD IDEA!!!
        //PLEASE USE THE System.Security.Cryptography.RNGCryptoServiceProvider TO GENERATE KEYS
        private readonly byte[] ENCRYPTION_KEY = new byte[] { 3, 13, 23, 33, 43, 53, 63, 73 };

        //Hard-coding IVs is even a worse idea! They should be created for each encryption.
        private readonly byte[] ENCRYPTION_IV = new byte[] { 5, 17, 29, 41, 53, 65, 77, 89 };

        public AuthManager(IHttpContextAccessor accessor, ApplicationDbContext context)
        {
            _httpContext = accessor.HttpContext;
            _dbContext = context;
        }

        public bool IsUserSignedIn()
        {
            try
            {
                return GetLoggedInUser() != null;
            }
            catch
            {
                //Swallowing any exception is a very bad idea!
                return false;
            }
        }

        public SiteUser GetLoggedInUser()
        {
            try
            {
                var authUserCookie = _httpContext.Request.Cookies[AUTH_COOKIE_USER_NAME];

                if (string.IsNullOrEmpty(authUserCookie))
                    return null;

                var authPasswordCookie = _httpContext.Request.Cookies[AUTH_COOKIE_USER_PASSWORD];

                if (string.IsNullOrEmpty(authPasswordCookie))
                    return null;

                var userName = authUserCookie;
                var password = Decrypt(authPasswordCookie);

                //var user = _dbContext.SiteUser.FirstOrDefault(u => u.UserName == userName && u.UserPassword == password);
                var query = $"SELECT * FROM SiteUser WHERE UserName = '{userName}' AND UserPassword = '{password}'"; //DAST test: SQL injection from cookie data
                var user = _dbContext.SiteUsers.FromSqlRaw(query).SingleOrDefault(); 

                return user;
            }
            catch
            {
                //Swallowing any exception is a very bad idea!
                return null;
            }
        }

        public void SaveChanges()
        {
            _dbContext.SaveChanges();
        }

        public bool UserExists(string userName)
        {
            return _dbContext.SiteUsers.Any(u => u.UserName == userName);
        }

        public SignInResult SignIn(string userName, string password)
        {
            var user = _dbContext.SiteUsers.SingleOrDefault(u => u.UserName == userName);

            if (user == null)
                return SignInResult.UserNotFound;
            else if (user.UserPassword != password) //No decryption - password stored in plaintext
                return SignInResult.PasswordMismatch;

            var options = new CookieOptions();
            options.Expires = DateTime.Now.AddYears(1);
            options.HttpOnly = false;
            options.SameSite = SameSiteMode.Lax;
            options.IsEssential = true;
            options.Secure = false;

            _httpContext.Response.Cookies.Append(AUTH_COOKIE_USER_NAME, userName, options);
            _httpContext.Response.Cookies.Append(AUTH_COOKIE_USER_PASSWORD, Encrypt(password), options);

            return SignInResult.Success;
        }

        public void SignOut()
        {
            var options = new CookieOptions();
            options.Expires = DateTime.Parse("1/1/1970");
            options.HttpOnly = false;
            options.SameSite = SameSiteMode.Lax;
            options.IsEssential = true;
            options.Secure = false;

            _httpContext.Response.Cookies.Delete(AUTH_COOKIE_USER_NAME, options);
            _httpContext.Response.Cookies.Delete(AUTH_COOKIE_USER_PASSWORD, options);
        }

        private string Encrypt(string toEncrypt)
        {
            byte[] plainTextBytes = UTF8Encoding.UTF8.GetBytes(toEncrypt);

            //DES is not safe - use AES instead
            var desService = new DESCryptoServiceProvider();

            desService.Key = ENCRYPTION_KEY;
            desService.IV = ENCRYPTION_IV;
            desService.Mode = CipherMode.ECB;
            desService.Padding = PaddingMode.PKCS7;

            using (var transform = desService.CreateEncryptor())
            { 
                byte[] encryptedBytes = transform.TransformFinalBlock(plainTextBytes, 0, plainTextBytes.Length);  
                return Convert.ToBase64String(encryptedBytes, 0, encryptedBytes.Length);                
            }
        }

        private string Decrypt(string toDecrypt)
        {
            byte[] encryptedBytes = Convert.FromBase64String(toDecrypt);

            //DES is not safe - use AES instead
            var desService = new DESCryptoServiceProvider();

            //Same as above, seeing if we can make this easier for SAST scanners to find
            desService.Key = new byte[] { 3, 13, 23, 33, 43, 53, 63, 73 };
            desService.IV = new byte[] { 5, 17, 29, 41, 53, 65, 77, 89 };

            desService.Mode = CipherMode.ECB;
            desService.Padding = PaddingMode.PKCS7;

            using (var transform = desService.CreateDecryptor())
            { 
                byte[] decryptedBytes = transform.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);
                return UTF8Encoding.UTF8.GetString(decryptedBytes);            
            }
        }
    }
}
